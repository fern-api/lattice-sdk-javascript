/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { mockServerPool } from "../mock-server/MockServerPool";
import { LatticeClient } from "../../src/Client";
import * as Lattice from "../../src/api/index";

describe("Tasks", () => {
    test("createTask (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new LatticeClient({ token: "test", environment: server.baseUrl });
        const rawRequestBody = {};
        const rawResponseBody = {
            version: { taskId: "taskId", definitionVersion: 1, statusVersion: 1 },
            displayName: "displayName",
            specification: { "@type": "@type" },
            createdBy: {
                system: { serviceName: "serviceName", entityId: "entityId", managesOwnScheduling: true },
                user: { userId: "userId" },
                team: { entityId: "entityId", members: [{}] },
            },
            lastUpdatedBy: {
                system: { serviceName: "serviceName", entityId: "entityId", managesOwnScheduling: true },
                user: { userId: "userId" },
                team: { entityId: "entityId", members: [{}] },
            },
            lastUpdateTime: "2024-01-15T09:30:00Z",
            status: {
                status: "STATUS_INVALID",
                taskError: { code: "ERROR_CODE_INVALID", message: "message" },
                progress: { "@type": "@type" },
                result: { "@type": "@type" },
                startTime: "2024-01-15T09:30:00Z",
                estimate: { "@type": "@type" },
                allocation: { activeAgents: [{}] },
            },
            scheduledTime: "2024-01-15T09:30:00Z",
            relations: { parentTaskId: "parentTaskId" },
            description: "description",
            isExecutedElsewhere: true,
            createTime: "2024-01-15T09:30:00Z",
            replication: { staleTime: "2024-01-15T09:30:00Z" },
            initialEntities: [{ snapshot: true }],
            owner: { entityId: "entityId" },
        };
        server
            .mockEndpoint()
            .post("/api/v1/tasks")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.tasks.createTask();
        expect(response).toEqual({
            version: {
                taskId: "taskId",
                definitionVersion: 1,
                statusVersion: 1,
            },
            displayName: "displayName",
            specification: {
                "@type": "@type",
            },
            createdBy: {
                system: {
                    serviceName: "serviceName",
                    entityId: "entityId",
                    managesOwnScheduling: true,
                },
                user: {
                    userId: "userId",
                },
                team: {
                    entityId: "entityId",
                    members: [{}],
                },
            },
            lastUpdatedBy: {
                system: {
                    serviceName: "serviceName",
                    entityId: "entityId",
                    managesOwnScheduling: true,
                },
                user: {
                    userId: "userId",
                },
                team: {
                    entityId: "entityId",
                    members: [{}],
                },
            },
            lastUpdateTime: "2024-01-15T09:30:00Z",
            status: {
                status: "STATUS_INVALID",
                taskError: {
                    code: "ERROR_CODE_INVALID",
                    message: "message",
                },
                progress: {
                    "@type": "@type",
                },
                result: {
                    "@type": "@type",
                },
                startTime: "2024-01-15T09:30:00Z",
                estimate: {
                    "@type": "@type",
                },
                allocation: {
                    activeAgents: [{}],
                },
            },
            scheduledTime: "2024-01-15T09:30:00Z",
            relations: {
                parentTaskId: "parentTaskId",
            },
            description: "description",
            isExecutedElsewhere: true,
            createTime: "2024-01-15T09:30:00Z",
            replication: {
                staleTime: "2024-01-15T09:30:00Z",
            },
            initialEntities: [
                {
                    snapshot: true,
                },
            ],
            owner: {
                entityId: "entityId",
            },
        });
    });

    test("createTask (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new LatticeClient({ token: "test", environment: server.baseUrl });
        const rawRequestBody = {
            taskId: undefined,
            displayName: undefined,
            description: undefined,
            specification: undefined,
            author: undefined,
            relations: undefined,
            isExecutedElsewhere: undefined,
            initialEntities: undefined,
        };
        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .post("/api/v1/tasks")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(400)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.tasks.createTask({
                taskId: undefined,
                displayName: undefined,
                description: undefined,
                specification: undefined,
                author: undefined,
                relations: undefined,
                isExecutedElsewhere: undefined,
                initialEntities: undefined,
            });
        }).rejects.toThrow(
            new Lattice.BadRequestError({
                key: "value",
            }),
        );
    });

    test("createTask (3)", async () => {
        const server = mockServerPool.createServer();
        const client = new LatticeClient({ token: "test", environment: server.baseUrl });
        const rawRequestBody = {
            taskId: undefined,
            displayName: undefined,
            description: undefined,
            specification: undefined,
            author: undefined,
            relations: undefined,
            isExecutedElsewhere: undefined,
            initialEntities: undefined,
        };
        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .post("/api/v1/tasks")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(401)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.tasks.createTask({
                taskId: undefined,
                displayName: undefined,
                description: undefined,
                specification: undefined,
                author: undefined,
                relations: undefined,
                isExecutedElsewhere: undefined,
                initialEntities: undefined,
            });
        }).rejects.toThrow(
            new Lattice.UnauthorizedError({
                key: "value",
            }),
        );
    });

    test("getTask (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new LatticeClient({ token: "test", environment: server.baseUrl });

        const rawResponseBody = {
            version: { taskId: "taskId", definitionVersion: 1, statusVersion: 1 },
            displayName: "displayName",
            specification: { "@type": "@type" },
            createdBy: {
                system: { serviceName: "serviceName", entityId: "entityId", managesOwnScheduling: true },
                user: { userId: "userId" },
                team: { entityId: "entityId", members: [{}] },
            },
            lastUpdatedBy: {
                system: { serviceName: "serviceName", entityId: "entityId", managesOwnScheduling: true },
                user: { userId: "userId" },
                team: { entityId: "entityId", members: [{}] },
            },
            lastUpdateTime: "2024-01-15T09:30:00Z",
            status: {
                status: "STATUS_INVALID",
                taskError: { code: "ERROR_CODE_INVALID", message: "message" },
                progress: { "@type": "@type" },
                result: { "@type": "@type" },
                startTime: "2024-01-15T09:30:00Z",
                estimate: { "@type": "@type" },
                allocation: { activeAgents: [{}] },
            },
            scheduledTime: "2024-01-15T09:30:00Z",
            relations: { parentTaskId: "parentTaskId" },
            description: "description",
            isExecutedElsewhere: true,
            createTime: "2024-01-15T09:30:00Z",
            replication: { staleTime: "2024-01-15T09:30:00Z" },
            initialEntities: [{ snapshot: true }],
            owner: { entityId: "entityId" },
        };
        server
            .mockEndpoint()
            .get("/api/v1/tasks/taskId")
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.tasks.getTask("taskId");
        expect(response).toEqual({
            version: {
                taskId: "taskId",
                definitionVersion: 1,
                statusVersion: 1,
            },
            displayName: "displayName",
            specification: {
                "@type": "@type",
            },
            createdBy: {
                system: {
                    serviceName: "serviceName",
                    entityId: "entityId",
                    managesOwnScheduling: true,
                },
                user: {
                    userId: "userId",
                },
                team: {
                    entityId: "entityId",
                    members: [{}],
                },
            },
            lastUpdatedBy: {
                system: {
                    serviceName: "serviceName",
                    entityId: "entityId",
                    managesOwnScheduling: true,
                },
                user: {
                    userId: "userId",
                },
                team: {
                    entityId: "entityId",
                    members: [{}],
                },
            },
            lastUpdateTime: "2024-01-15T09:30:00Z",
            status: {
                status: "STATUS_INVALID",
                taskError: {
                    code: "ERROR_CODE_INVALID",
                    message: "message",
                },
                progress: {
                    "@type": "@type",
                },
                result: {
                    "@type": "@type",
                },
                startTime: "2024-01-15T09:30:00Z",
                estimate: {
                    "@type": "@type",
                },
                allocation: {
                    activeAgents: [{}],
                },
            },
            scheduledTime: "2024-01-15T09:30:00Z",
            relations: {
                parentTaskId: "parentTaskId",
            },
            description: "description",
            isExecutedElsewhere: true,
            createTime: "2024-01-15T09:30:00Z",
            replication: {
                staleTime: "2024-01-15T09:30:00Z",
            },
            initialEntities: [
                {
                    snapshot: true,
                },
            ],
            owner: {
                entityId: "entityId",
            },
        });
    });

    test("getTask (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new LatticeClient({ token: "test", environment: server.baseUrl });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .get("/api/v1/tasks/taskId")
            .respondWith()
            .statusCode(400)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.tasks.getTask("taskId");
        }).rejects.toThrow(
            new Lattice.BadRequestError({
                key: "value",
            }),
        );
    });

    test("getTask (3)", async () => {
        const server = mockServerPool.createServer();
        const client = new LatticeClient({ token: "test", environment: server.baseUrl });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .get("/api/v1/tasks/taskId")
            .respondWith()
            .statusCode(401)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.tasks.getTask("taskId");
        }).rejects.toThrow(
            new Lattice.UnauthorizedError({
                key: "value",
            }),
        );
    });

    test("getTask (4)", async () => {
        const server = mockServerPool.createServer();
        const client = new LatticeClient({ token: "test", environment: server.baseUrl });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .get("/api/v1/tasks/taskId")
            .respondWith()
            .statusCode(404)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.tasks.getTask("taskId");
        }).rejects.toThrow(
            new Lattice.NotFoundError({
                key: "value",
            }),
        );
    });

    test("updateTaskStatus (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new LatticeClient({ token: "test", environment: server.baseUrl });
        const rawRequestBody = {};
        const rawResponseBody = {
            version: { taskId: "taskId", definitionVersion: 1, statusVersion: 1 },
            displayName: "displayName",
            specification: { "@type": "@type" },
            createdBy: {
                system: { serviceName: "serviceName", entityId: "entityId", managesOwnScheduling: true },
                user: { userId: "userId" },
                team: { entityId: "entityId", members: [{}] },
            },
            lastUpdatedBy: {
                system: { serviceName: "serviceName", entityId: "entityId", managesOwnScheduling: true },
                user: { userId: "userId" },
                team: { entityId: "entityId", members: [{}] },
            },
            lastUpdateTime: "2024-01-15T09:30:00Z",
            status: {
                status: "STATUS_INVALID",
                taskError: { code: "ERROR_CODE_INVALID", message: "message" },
                progress: { "@type": "@type" },
                result: { "@type": "@type" },
                startTime: "2024-01-15T09:30:00Z",
                estimate: { "@type": "@type" },
                allocation: { activeAgents: [{}] },
            },
            scheduledTime: "2024-01-15T09:30:00Z",
            relations: { parentTaskId: "parentTaskId" },
            description: "description",
            isExecutedElsewhere: true,
            createTime: "2024-01-15T09:30:00Z",
            replication: { staleTime: "2024-01-15T09:30:00Z" },
            initialEntities: [{ snapshot: true }],
            owner: { entityId: "entityId" },
        };
        server
            .mockEndpoint()
            .put("/api/v1/tasks/taskId/status")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.tasks.updateTaskStatus("taskId");
        expect(response).toEqual({
            version: {
                taskId: "taskId",
                definitionVersion: 1,
                statusVersion: 1,
            },
            displayName: "displayName",
            specification: {
                "@type": "@type",
            },
            createdBy: {
                system: {
                    serviceName: "serviceName",
                    entityId: "entityId",
                    managesOwnScheduling: true,
                },
                user: {
                    userId: "userId",
                },
                team: {
                    entityId: "entityId",
                    members: [{}],
                },
            },
            lastUpdatedBy: {
                system: {
                    serviceName: "serviceName",
                    entityId: "entityId",
                    managesOwnScheduling: true,
                },
                user: {
                    userId: "userId",
                },
                team: {
                    entityId: "entityId",
                    members: [{}],
                },
            },
            lastUpdateTime: "2024-01-15T09:30:00Z",
            status: {
                status: "STATUS_INVALID",
                taskError: {
                    code: "ERROR_CODE_INVALID",
                    message: "message",
                },
                progress: {
                    "@type": "@type",
                },
                result: {
                    "@type": "@type",
                },
                startTime: "2024-01-15T09:30:00Z",
                estimate: {
                    "@type": "@type",
                },
                allocation: {
                    activeAgents: [{}],
                },
            },
            scheduledTime: "2024-01-15T09:30:00Z",
            relations: {
                parentTaskId: "parentTaskId",
            },
            description: "description",
            isExecutedElsewhere: true,
            createTime: "2024-01-15T09:30:00Z",
            replication: {
                staleTime: "2024-01-15T09:30:00Z",
            },
            initialEntities: [
                {
                    snapshot: true,
                },
            ],
            owner: {
                entityId: "entityId",
            },
        });
    });

    test("updateTaskStatus (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new LatticeClient({ token: "test", environment: server.baseUrl });
        const rawRequestBody = { statusVersion: undefined, newStatus: undefined, author: undefined };
        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .put("/api/v1/tasks/taskId/status")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(400)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.tasks.updateTaskStatus("taskId", {
                statusVersion: undefined,
                newStatus: undefined,
                author: undefined,
            });
        }).rejects.toThrow(
            new Lattice.BadRequestError({
                key: "value",
            }),
        );
    });

    test("updateTaskStatus (3)", async () => {
        const server = mockServerPool.createServer();
        const client = new LatticeClient({ token: "test", environment: server.baseUrl });
        const rawRequestBody = { statusVersion: undefined, newStatus: undefined, author: undefined };
        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .put("/api/v1/tasks/taskId/status")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(401)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.tasks.updateTaskStatus("taskId", {
                statusVersion: undefined,
                newStatus: undefined,
                author: undefined,
            });
        }).rejects.toThrow(
            new Lattice.UnauthorizedError({
                key: "value",
            }),
        );
    });

    test("updateTaskStatus (4)", async () => {
        const server = mockServerPool.createServer();
        const client = new LatticeClient({ token: "test", environment: server.baseUrl });
        const rawRequestBody = { statusVersion: undefined, newStatus: undefined, author: undefined };
        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .put("/api/v1/tasks/taskId/status")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(404)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.tasks.updateTaskStatus("taskId", {
                statusVersion: undefined,
                newStatus: undefined,
                author: undefined,
            });
        }).rejects.toThrow(
            new Lattice.NotFoundError({
                key: "value",
            }),
        );
    });

    test("queryTasks (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new LatticeClient({ token: "test", environment: server.baseUrl });
        const rawRequestBody = {};
        const rawResponseBody = {
            tasks: [
                {
                    displayName: "displayName",
                    lastUpdateTime: "2024-01-15T09:30:00Z",
                    scheduledTime: "2024-01-15T09:30:00Z",
                    description: "description",
                    isExecutedElsewhere: true,
                    createTime: "2024-01-15T09:30:00Z",
                    initialEntities: [{}],
                },
            ],
            nextPageToken: "nextPageToken",
        };
        server
            .mockEndpoint()
            .post("/api/v1/tasks/query")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.tasks.queryTasks();
        expect(response).toEqual({
            tasks: [
                {
                    displayName: "displayName",
                    lastUpdateTime: "2024-01-15T09:30:00Z",
                    scheduledTime: "2024-01-15T09:30:00Z",
                    description: "description",
                    isExecutedElsewhere: true,
                    createTime: "2024-01-15T09:30:00Z",
                    initialEntities: [{}],
                },
            ],
            nextPageToken: "nextPageToken",
        });
    });

    test("queryTasks (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new LatticeClient({ token: "test", environment: server.baseUrl });
        const rawRequestBody = {
            pageToken: undefined,
            parentTaskId: undefined,
            statusFilter: undefined,
            updateTimeRange: undefined,
        };
        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .post("/api/v1/tasks/query")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(400)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.tasks.queryTasks({
                pageToken: undefined,
                parentTaskId: undefined,
                statusFilter: undefined,
                updateTimeRange: undefined,
            });
        }).rejects.toThrow(
            new Lattice.BadRequestError({
                key: "value",
            }),
        );
    });

    test("queryTasks (3)", async () => {
        const server = mockServerPool.createServer();
        const client = new LatticeClient({ token: "test", environment: server.baseUrl });
        const rawRequestBody = {
            pageToken: undefined,
            parentTaskId: undefined,
            statusFilter: undefined,
            updateTimeRange: undefined,
        };
        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .post("/api/v1/tasks/query")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(401)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.tasks.queryTasks({
                pageToken: undefined,
                parentTaskId: undefined,
                statusFilter: undefined,
                updateTimeRange: undefined,
            });
        }).rejects.toThrow(
            new Lattice.UnauthorizedError({
                key: "value",
            }),
        );
    });

    test("queryTasks (4)", async () => {
        const server = mockServerPool.createServer();
        const client = new LatticeClient({ token: "test", environment: server.baseUrl });
        const rawRequestBody = {
            pageToken: undefined,
            parentTaskId: undefined,
            statusFilter: undefined,
            updateTimeRange: undefined,
        };
        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .post("/api/v1/tasks/query")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(404)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.tasks.queryTasks({
                pageToken: undefined,
                parentTaskId: undefined,
                statusFilter: undefined,
                updateTimeRange: undefined,
            });
        }).rejects.toThrow(
            new Lattice.NotFoundError({
                key: "value",
            }),
        );
    });

    test("listenAsAgent (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new LatticeClient({ token: "test", environment: server.baseUrl });
        const rawRequestBody = {};
        const rawResponseBody = {
            executeRequest: {
                task: {
                    displayName: "displayName",
                    lastUpdateTime: "2024-01-15T09:30:00Z",
                    scheduledTime: "2024-01-15T09:30:00Z",
                    description: "description",
                    isExecutedElsewhere: true,
                    createTime: "2024-01-15T09:30:00Z",
                    initialEntities: [{}],
                },
            },
            cancelRequest: { taskId: "taskId" },
            completeRequest: { taskId: "taskId" },
        };
        server
            .mockEndpoint()
            .post("/api/v1/agent/listen")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.tasks.listenAsAgent();
        expect(response).toEqual({
            executeRequest: {
                task: {
                    displayName: "displayName",
                    lastUpdateTime: "2024-01-15T09:30:00Z",
                    scheduledTime: "2024-01-15T09:30:00Z",
                    description: "description",
                    isExecutedElsewhere: true,
                    createTime: "2024-01-15T09:30:00Z",
                    initialEntities: [{}],
                },
            },
            cancelRequest: {
                taskId: "taskId",
            },
            completeRequest: {
                taskId: "taskId",
            },
        });
    });

    test("listenAsAgent (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new LatticeClient({ token: "test", environment: server.baseUrl });
        const rawRequestBody = { agentSelector: undefined };
        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .post("/api/v1/agent/listen")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(400)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.tasks.listenAsAgent({
                agentSelector: undefined,
            });
        }).rejects.toThrow(
            new Lattice.BadRequestError({
                key: "value",
            }),
        );
    });

    test("listenAsAgent (3)", async () => {
        const server = mockServerPool.createServer();
        const client = new LatticeClient({ token: "test", environment: server.baseUrl });
        const rawRequestBody = { agentSelector: undefined };
        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .post("/api/v1/agent/listen")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(401)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.tasks.listenAsAgent({
                agentSelector: undefined,
            });
        }).rejects.toThrow(
            new Lattice.UnauthorizedError({
                key: "value",
            }),
        );
    });
});
